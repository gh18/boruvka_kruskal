Алгоритм Борувки-Краскала

1. В общем виде:
    1) сортируем ребра графа по возрастанию весов
    2) тривиальный (без ребер) лес объявляем растущим
    3) проходим ребра в порядке сортировки
    4) для каждого ребра:
        - если вершины, соединенные этим ребром, лежат в разных деревьях растущего леса, то объединяем эти деревья
        в одно, а ребро добавляем к остову, который строим
        - если вершины лежат в одном дереве, исключаем его из рассматриваемых
    5) Если есть нерассмотренные ребра и не все деревья объединены в одно дерево, переходим на шаг 3)
    6) иначе СТОП

Таким образом, в качестве е(i) выбираем ребро минимального веса среди внешних к остовному лесу F(i-1). Если одна
из двух компонент связности леса содержит концевую вершину ребра e(i), а F(i-1) продолжить до минимального остова,
то лес F(i) = F(i-1) + e(i) обладает тем же свойством.

2. Реализация алгоритма
    ВХОД: связный взвешенный граф; ВЫХОД: минимальный остов графа (плюс его вес)

    - парсим входные данные и формируем граф (функция make_graph())
        - заводим атрибуты-списки name, next, size (понадобятся для слияния деревьев)
        - в ней же сортируем ребра по весу (то есть создаем отсортированную очередь q)          # стр. 83
    - процедура слияния деревьев - одна из основных операций алгоритма:
        - иммитируем одномерные массивы с помощью созданный списков name, next, size
        - тогда name[u] = name[w] <=> вершины u и w лежат в одной компоненте связности леса из последовательности
        остовных лесов, которую строит алгоритм Б-К
        - next задает кольцевой список на вершинах компоненты связности
        - size[v] содержит число вершин в компоненте связности (в которой v лежит), если v = name[w]
        - тогда деревья будут сливаться по внешнему ребру vw (v из одной компоненты связности, w из другой)
        - назначем p = name[w], u = next[w]
        - по сути мы просто меняем в цмкле значения name[w] для всех вершин w из другой компоненты, а потом исправляем
        значения списка next[p] на сумму вершин из каждой компоненты
    - строим минимальный растущий остов (minimum spanning tree):
        - 27-29 строки - формируем первый из последовательности остовных лесов
        - пока кол-во ребер не равно кол-ву вершин минус 1, достаем из очереди вершины
        - проверяем, что они лежат в различных деревьях
        - запускаем процедуру слияния
    - записываем выходные данные в файл

По большому счету мы объявляем пеньковый лес Т растущим (то есть пустое множество пытаемся "вырастить")
Пока Т не сольется в одно дерево (|T| < n-1), выбираем минимальное по весу ребро, внешнее к нему
Проводим слияние по этому ребру
